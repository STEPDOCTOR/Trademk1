"""Base strategy framework for trading strategies."""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Tuple
from uuid import uuid4

import numpy as np
import pandas as pd


class SignalType(str, Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE = "close"  # Close position


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    strategy_id: str
    symbol: str
    signal_type: SignalType
    strength: float  # Signal strength 0-1
    quantity: Optional[float] = None
    reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.utcnow)
    
    def to_trade_signal(self) -> Optional[Dict[str, Any]]:
        """Convert to execution engine trade signal."""
        if self.signal_type in [SignalType.BUY, SignalType.SELL]:
            return {
                "symbol": self.symbol,
                "side": self.signal_type.value,
                "qty": self.quantity,
                "reason": f"{self.strategy_id}: {self.reason}",
                "metadata": {
                    "strategy_id": self.strategy_id,
                    "signal_strength": self.strength,
                    **self.metadata
                }
            }
        return None


@dataclass
class StrategyConfig:
    """Configuration for a trading strategy."""
    strategy_id: str
    name: str
    symbols: List[str]
    enabled: bool = True
    parameters: Dict[str, Any] = field(default_factory=dict)
    risk_parameters: Dict[str, Any] = field(default_factory=dict)
    
    
class BaseStrategy(ABC):
    """Abstract base class for all trading strategies."""
    
    def __init__(self, config: StrategyConfig):
        self.config = config
        self.strategy_id = config.strategy_id
        self.name = config.name
        self.symbols = config.symbols
        self.parameters = config.parameters
        self.risk_parameters = config.risk_parameters
        
        # Strategy state
        self.positions: Dict[str, float] = {}
        self.last_signals: Dict[str, Signal] = {}
        self.performance_metrics: Dict[str, Any] = {}
        
    @abstractmethod
    async def calculate_signals(
        self, 
        market_data: pd.DataFrame,
        current_positions: Dict[str, float]
    ) -> List[Signal]:
        """
        Calculate trading signals based on market data.
        
        Args:
            market_data: DataFrame with columns [symbol, timestamp, open, high, low, close, volume]
            current_positions: Current position quantities by symbol
            
        Returns:
            List of trading signals
        """
        pass
        
    @abstractmethod
    def validate_parameters(self) -> Tuple[bool, Optional[str]]:
        """
        Validate strategy parameters.
        
        Returns:
            Tuple of (is_valid, error_message)
        """
        pass
        
    def preprocess_data(self, market_data: pd.DataFrame) -> pd.DataFrame:
        """Preprocess market data before signal calculation."""
        # Ensure data is sorted by timestamp
        market_data = market_data.sort_values('timestamp')
        
        # Remove any duplicates
        market_data = market_data.drop_duplicates(subset=['symbol', 'timestamp'])
        
        # Forward fill missing values
        market_data = market_data.fillna(method='ffill')
        
        return market_data
        
    def apply_risk_filters(self, signals: List[Signal]) -> List[Signal]:
        """Apply risk management filters to signals."""
        filtered_signals = []
        
        for signal in signals:
            # Check position limits
            max_positions = self.risk_parameters.get('max_positions', 10)
            if len(self.positions) >= max_positions and signal.signal_type == SignalType.BUY:
                if signal.symbol not in self.positions:
                    continue
                    
            # Check signal frequency
            min_signal_interval = self.risk_parameters.get('min_signal_interval_minutes', 5)
            if signal.symbol in self.last_signals:
                last_signal = self.last_signals[signal.symbol]
                time_diff = (signal.timestamp - last_signal.timestamp).total_seconds() / 60
                if time_diff < min_signal_interval:
                    continue
                    
            # Check signal strength threshold
            min_strength = self.risk_parameters.get('min_signal_strength', 0.3)
            if signal.strength < min_strength:
                continue
                
            filtered_signals.append(signal)
            
        return filtered_signals
        
    async def execute(
        self,
        market_data: pd.DataFrame,
        current_positions: Dict[str, float]
    ) -> List[Signal]:
        """
        Execute strategy and generate signals.
        
        Args:
            market_data: Historical market data
            current_positions: Current positions
            
        Returns:
            List of filtered trading signals
        """
        # Update positions
        self.positions = current_positions.copy()
        
        # Preprocess data
        processed_data = self.preprocess_data(market_data)
        
        # Calculate raw signals
        signals = await self.calculate_signals(processed_data, current_positions)
        
        # Apply risk filters
        filtered_signals = self.apply_risk_filters(signals)
        
        # Update last signals
        for signal in filtered_signals:
            self.last_signals[signal.symbol] = signal
            
        return filtered_signals
        
    def calculate_position_size(
        self,
        symbol: str,
        signal_strength: float,
        account_value: float,
        current_price: float
    ) -> float:
        """Calculate position size based on Kelly criterion or fixed sizing."""
        sizing_method = self.risk_parameters.get('sizing_method', 'fixed')
        
        if sizing_method == 'fixed':
            # Fixed percentage of account
            position_pct = self.risk_parameters.get('position_size_pct', 0.02)
            position_value = account_value * position_pct
            
        elif sizing_method == 'kelly':
            # Kelly criterion with safety factor
            win_rate = self.performance_metrics.get('win_rate', 0.5)
            avg_win = self.performance_metrics.get('avg_win', 0.02)
            avg_loss = self.performance_metrics.get('avg_loss', 0.01)
            
            if avg_loss > 0:
                kelly_pct = (win_rate * avg_win - (1 - win_rate) * avg_loss) / avg_win
                safety_factor = self.risk_parameters.get('kelly_safety_factor', 0.25)
                position_pct = max(0, min(kelly_pct * safety_factor, 0.25))  # Cap at 25%
            else:
                position_pct = 0.02  # Default fallback
                
            position_value = account_value * position_pct
            
        elif sizing_method == 'volatility':
            # Size based on volatility
            target_risk = self.risk_parameters.get('target_risk_pct', 0.01)
            volatility = self.performance_metrics.get(f'{symbol}_volatility', 0.02)
            
            if volatility > 0:
                position_value = (account_value * target_risk) / volatility
            else:
                position_value = account_value * 0.02
                
        else:
            # Default to 2% of account
            position_value = account_value * 0.02
            
        # Apply signal strength scaling
        position_value *= signal_strength
        
        # Convert to shares/units
        quantity = position_value / current_price
        
        # Apply min/max constraints
        min_position_value = self.risk_parameters.get('min_position_value', 100)
        max_position_value = self.risk_parameters.get('max_position_value', 10000)
        
        if position_value < min_position_value:
            return 0  # Skip too small positions
            
        if position_value > max_position_value:
            quantity = max_position_value / current_price
            
        return round(quantity, 2)
        
    def update_performance_metrics(self, metrics: Dict[str, Any]):
        """Update strategy performance metrics."""
        self.performance_metrics.update(metrics)
        
    def get_status(self) -> Dict[str, Any]:
        """Get current strategy status."""
        return {
            "strategy_id": self.strategy_id,
            "name": self.name,
            "enabled": self.config.enabled,
            "symbols": self.symbols,
            "positions": len(self.positions),
            "last_signals": {
                symbol: {
                    "type": signal.signal_type.value,
                    "strength": signal.strength,
                    "timestamp": signal.timestamp.isoformat()
                }
                for symbol, signal in self.last_signals.items()
            },
            "performance": self.performance_metrics
        }